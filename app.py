# -*- coding: utf-8 -*-
"""imovel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DZAQZfrXvTy358Vg2qfUg_ge6b3kcgBy
"""

# app.py
import pandas as pd
import requests
import io
import itertools
from collections import defaultdict
import gradio as gr
import time

# ğŸ”§ CONFIGURAÃ‡Ã•ES GLOBAIS
# Certifique-se de que este FILE_ID esteja acessÃ­vel publicamente ou para "Qualquer pessoa com o link"
FILE_ID = "1iz6SKyiqxTjMz_MuDj6quc8pEGXErWRk"
URL = f"https://drive.google.com/uc?export=download&id={FILE_ID}"

# VariÃ¡vel global para armazenar o DataFrame
df = None

def carregar_planilha():
    """Carrega e prepara a planilha para anÃ¡lise."""
    global df
    try:
        print("â³ Carregando planilha...")
        response = requests.get(URL)
        response.raise_for_status()
        data = io.BytesIO(response.content)
        df = pd.read_excel(data)

        # Padroniza nomes das colunas
        df.columns = df.columns.str.strip().str.lower().str.replace(" ", "_")

        # Converte colunas numÃ©ricas
        colunas_numericas = ['valor_credito', 'valor_entrada', 'valor_parcela', 'saldo_devedor', 'qtd_parcelas']
        for coluna in colunas_numericas:
            if coluna in df.columns:
                df[coluna] = pd.to_numeric(df[coluna], errors='coerce').fillna(0)

        # Verifica colunas essenciais
        if 'tipo_do_bem' not in df.columns or 'administradora' not in df.columns:
            raise ValueError("Colunas essenciais nÃ£o encontradas")

        # Remove duplicatas
        df.drop_duplicates(inplace=True)

        print("âœ… Planilha carregada com sucesso")
        return True

    except Exception as e:
        print(f"âŒ Erro ao carregar planilha: {str(e)}")
        return False

def agrupar_por_administradora(dataframe):
    """Agrupa cotas por administradora."""
    grupos = defaultdict(list)
    for _, row in dataframe.iterrows():
        grupos[row['administradora']].append(row.to_dict())
    return grupos

def buscar_combinacoes(credito_desejado, entrada_desejada, parcela_desejada, administradoras=None):
    """Busca combinaÃ§Ãµes de cotas dentro dos parÃ¢metros especificados."""
    # Garante que o DataFrame estÃ¡ carregado
    if df is None:
        # Tenta carregar se ainda nÃ£o foi carregado
        if not carregar_planilha():
            return "âŒ Erro: Planilha nÃ£o carregada. Por favor, tente novamente."

    # Filtra por tipo de bem e administradoras
    df_filtrado = df[df['tipo_do_bem'].str.lower() == 'imovel']
    if administradoras:
        # Certifica-se de que administradoras Ã© uma lista (Gradio retorna tupla)
        if isinstance(administradoras, tuple):
            administradoras = list(administradoras)
        df_filtrado = df_filtrado[df_filtrado['administradora'].isin(administradoras)]

    if df_filtrado.empty:
        return "ğŸš« Nenhuma cota encontrada com os filtros aplicados. Tente ajustar os parÃ¢metros."

    # Define faixas de tolerÃ¢ncia
    credito_min, credito_max = credito_desejado * 0.93, credito_desejado * 1.07
    entrada_min, entrada_max = entrada_desejada * 0.93, entrada_desejada * 1.07
    parcela_min, parcela_max = parcela_desejada * 0.75, parcela_desejada * 1.25

    grupos = agrupar_por_administradora(df_filtrado)
    resultados = []

    for adm, cotas in grupos.items():
        for r in range(1, min(3, len(cotas)) + 1):  # MÃ¡ximo 3 cotas por combinaÃ§Ã£o
            for combinacao in itertools.combinations(cotas, r):
                total_credito = sum(c['valor_credito'] for c in combinacao)
                total_entrada = sum(c['valor_entrada'] for c in combinacao)
                total_parcelas = sum(c['valor_parcela'] for c in combinacao)

                if (credito_min <= total_credito <= credito_max and
                    entrada_min <= total_entrada <= entrada_max and
                    parcela_min <= total_parcelas <= parcela_max):

                    total_saldo = sum(c['saldo_devedor'] for c in combinacao)
                    valor_final = round(total_entrada + total_saldo, 2)
                    diferenca = abs(valor_final - total_credito) # DiferenÃ§a do valor final pelo crÃ©dito (para ordenaÃ§Ã£o)

                    resultados.append((adm, combinacao, diferenca))

    if not resultados:
        return "ğŸš« Nenhuma combinaÃ§Ã£o adequada encontrada com os parÃ¢metros fornecidos."

    resultados.sort(key=lambda x: x[2]) # Ordena pela diferenÃ§a

    return formatar_resultados(resultados)

def formatar_resultados(resultados):
    """Formata os resultados para exibiÃ§Ã£o."""
    resposta = ""
    # Limita a 15 resultados para evitar saÃ­das muito longas
    for idx, (adm, combinacao, _) in enumerate(resultados[:15], 1):
        codigos = [str(c.get('codigo', 'N/A')) for c in combinacao] # Adicionado .get para seguranÃ§a
        total_credito = sum(c['valor_credito'] for c in combinacao)
        total_entrada = sum(c['valor_entrada'] for c in combinacao)
        total_saldo = sum(c['saldo_devedor'] for c in combinacao)
        total_parcelas = sum(c['valor_parcela'] for c in combinacao)
        maior_prazo = max(int(c.get('qtd_parcelas', 0)) for c in combinacao) # Adicionado .get para seguranÃ§a

        valor_final = round(total_entrada + total_saldo, 2)
        credito_real = round(total_credito - total_entrada, 2)
        taxa_total = total_saldo - credito_real
        taxa_percentual = (taxa_total / credito_real) * 100 if credito_real > 0 else 0
        taxa_mensal = taxa_percentual / maior_prazo if maior_prazo > 0 else 0

        resposta += f"""
--- COMBINAÃ‡ÃƒO {idx} ---
ğŸ¢ Administradora: {adm}
ğŸ”¢ CÃ³digos: {', '.join(codigos)}
ğŸ’° CrÃ©dito Total: R$ {total_credito:,.2f}
ğŸ’µ Entrada (+comissÃ£o): R$ {total_entrada:,.2f}
ğŸ“‰ Saldo Devedor: R$ {total_saldo:,.2f}
ğŸ’² Parcela: R$ {total_parcelas:,.2f}
â³ Prazo: {maior_prazo} meses
ğŸ”š Valor Final: R$ {valor_final:,.2f}
ğŸ’  CrÃ©dito LÃ­quido: R$ {credito_real:,.2f}
ğŸ“Š Taxa Total: {taxa_percentual:.2f}% (R$ {taxa_total:,.2f})
ğŸ—“ï¸ Taxa Mensal: {taxa_mensal:.2f}%
ğŸ—“ï¸ Taxa Anual: {taxa_mensal * 12:.2f}%
"""
    return resposta

# Carrega a planilha uma vez quando o aplicativo inicia
carregar_planilha()

# Prepara a lista de administradoras para o Gradio
def get_administradoras_options():
    if df is not None:
        adm_list = df[df['tipo_do_bem'].str.lower() == 'imovel']['administradora'].unique()
        return sorted(adm_list)
    return []

# Criando a interface Gradio
with gr.Blocks(title="Sistema de Busca de ConsÃ³rcio ImÃ³vel") as demo:
    gr.Markdown("# ğŸ  Busca de CombinaÃ§Ãµes de ConsÃ³rcio ImÃ³vel")
    gr.Markdown("Insira os valores desejados para crÃ©dito, entrada e parcela, e filtre por administradora.")

    with gr.Row():
        credito_input = gr.Number(label="CrÃ©dito Desejado (R$)", value=300000, step=1000)
        entrada_input = gr.Number(label="Entrada Desejada (R$)", value=30000, step=1000)
        parcela_input = gr.Number(label="Parcela Desejada (R$)", value=1500, step=100)

    administradoras_multiselect = gr.CheckboxGroup(
        label="Filtrar por Administradoras",
        choices=get_administradoras_options(),
        value=get_administradoras_options() # Seleciona todas por padrÃ£o
    )

    submit_btn = gr.Button("ğŸ” Buscar CombinaÃ§Ãµes", variant="primary")

    output_text = gr.Textbox(label="Resultados da Busca", lines=20, max_lines=40, interactive=False, placeholder="Os resultados aparecerÃ£o aqui...")

    submit_btn.click(
        fn=buscar_combinacoes,
        inputs=[credito_input, entrada_input, parcela_input, administradoras_multiselect],
        outputs=output_text
    )

    gr.Markdown("---")
    gr.Markdown("Desenvolvido para auxiliar na busca por cotas de consÃ³rcio ideais.")

# Inicia o aplicativo Gradio
if __name__ == "__main__":
    demo.launch() # VocÃª nÃ£o precisa disso no Colab, mas sim no arquivo que vocÃª farÃ¡ o deploy
