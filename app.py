# -*- coding: utf-8 -*-
"""imovel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DZAQZfrXvTy358Vg2qfUg_ge6b3kcgBy
"""

# app.py
import pandas as pd
import requests
import io
import itertools
from collections import defaultdict
import gradio as gr
import time

# 🔧 CONFIGURAÇÕES GLOBAIS
# Certifique-se de que este FILE_ID esteja acessível publicamente ou para "Qualquer pessoa com o link"
FILE_ID = "1iz6SKyiqxTjMz_MuDj6quc8pEGXErWRk"
URL = f"https://drive.google.com/uc?export=download&id={FILE_ID}"

# Variável global para armazenar o DataFrame
df = None

def carregar_planilha():
    """Carrega e prepara a planilha para análise."""
    global df
    try:
        print("⏳ Carregando planilha...")
        response = requests.get(URL)
        response.raise_for_status()
        data = io.BytesIO(response.content)
        df = pd.read_excel(data)

        # Padroniza nomes das colunas
        df.columns = df.columns.str.strip().str.lower().str.replace(" ", "_")

        # Converte colunas numéricas
        colunas_numericas = ['valor_credito', 'valor_entrada', 'valor_parcela', 'saldo_devedor', 'qtd_parcelas']
        for coluna in colunas_numericas:
            if coluna in df.columns:
                df[coluna] = pd.to_numeric(df[coluna], errors='coerce').fillna(0)

        # Verifica colunas essenciais
        if 'tipo_do_bem' not in df.columns or 'administradora' not in df.columns:
            raise ValueError("Colunas essenciais não encontradas")

        # Remove duplicatas
        df.drop_duplicates(inplace=True)

        print("✅ Planilha carregada com sucesso")
        return True

    except Exception as e:
        print(f"❌ Erro ao carregar planilha: {str(e)}")
        return False

def agrupar_por_administradora(dataframe):
    """Agrupa cotas por administradora."""
    grupos = defaultdict(list)
    for _, row in dataframe.iterrows():
        grupos[row['administradora']].append(row.to_dict())
    return grupos

def buscar_combinacoes(credito_desejado, entrada_desejada, parcela_desejada, administradoras=None):
    """Busca combinações de cotas dentro dos parâmetros especificados."""
    # Garante que o DataFrame está carregado
    if df is None:
        # Tenta carregar se ainda não foi carregado
        if not carregar_planilha():
            return "❌ Erro: Planilha não carregada. Por favor, tente novamente."

    # Filtra por tipo de bem e administradoras
    df_filtrado = df[df['tipo_do_bem'].str.lower() == 'imovel']
    if administradoras:
        # Certifica-se de que administradoras é uma lista (Gradio retorna tupla)
        if isinstance(administradoras, tuple):
            administradoras = list(administradoras)
        df_filtrado = df_filtrado[df_filtrado['administradora'].isin(administradoras)]

    if df_filtrado.empty:
        return "🚫 Nenhuma cota encontrada com os filtros aplicados. Tente ajustar os parâmetros."

    # Define faixas de tolerância
    credito_min, credito_max = credito_desejado * 0.93, credito_desejado * 1.07
    entrada_min, entrada_max = entrada_desejada * 0.93, entrada_desejada * 1.07
    parcela_min, parcela_max = parcela_desejada * 0.75, parcela_desejada * 1.25

    grupos = agrupar_por_administradora(df_filtrado)
    resultados = []

    for adm, cotas in grupos.items():
        for r in range(1, min(3, len(cotas)) + 1):  # Máximo 3 cotas por combinação
            for combinacao in itertools.combinations(cotas, r):
                total_credito = sum(c['valor_credito'] for c in combinacao)
                total_entrada = sum(c['valor_entrada'] for c in combinacao)
                total_parcelas = sum(c['valor_parcela'] for c in combinacao)

                if (credito_min <= total_credito <= credito_max and
                    entrada_min <= total_entrada <= entrada_max and
                    parcela_min <= total_parcelas <= parcela_max):

                    total_saldo = sum(c['saldo_devedor'] for c in combinacao)
                    valor_final = round(total_entrada + total_saldo, 2)
                    diferenca = abs(valor_final - total_credito) # Diferença do valor final pelo crédito (para ordenação)

                    resultados.append((adm, combinacao, diferenca))

    if not resultados:
        return "🚫 Nenhuma combinação adequada encontrada com os parâmetros fornecidos."

    resultados.sort(key=lambda x: x[2]) # Ordena pela diferença

    return formatar_resultados(resultados)

def formatar_resultados(resultados):
    """Formata os resultados para exibição."""
    resposta = ""
    # Limita a 15 resultados para evitar saídas muito longas
    for idx, (adm, combinacao, _) in enumerate(resultados[:15], 1):
        codigos = [str(c.get('codigo', 'N/A')) for c in combinacao] # Adicionado .get para segurança
        total_credito = sum(c['valor_credito'] for c in combinacao)
        total_entrada = sum(c['valor_entrada'] for c in combinacao)
        total_saldo = sum(c['saldo_devedor'] for c in combinacao)
        total_parcelas = sum(c['valor_parcela'] for c in combinacao)
        maior_prazo = max(int(c.get('qtd_parcelas', 0)) for c in combinacao) # Adicionado .get para segurança

        valor_final = round(total_entrada + total_saldo, 2)
        credito_real = round(total_credito - total_entrada, 2)
        taxa_total = total_saldo - credito_real
        taxa_percentual = (taxa_total / credito_real) * 100 if credito_real > 0 else 0
        taxa_mensal = taxa_percentual / maior_prazo if maior_prazo > 0 else 0

        resposta += f"""
--- COMBINAÇÃO {idx} ---
🏢 Administradora: {adm}
🔢 Códigos: {', '.join(codigos)}
💰 Crédito Total: R$ {total_credito:,.2f}
💵 Entrada (+comissão): R$ {total_entrada:,.2f}
📉 Saldo Devedor: R$ {total_saldo:,.2f}
💲 Parcela: R$ {total_parcelas:,.2f}
⏳ Prazo: {maior_prazo} meses
🔚 Valor Final: R$ {valor_final:,.2f}
💠 Crédito Líquido: R$ {credito_real:,.2f}
📊 Taxa Total: {taxa_percentual:.2f}% (R$ {taxa_total:,.2f})
🗓️ Taxa Mensal: {taxa_mensal:.2f}%
🗓️ Taxa Anual: {taxa_mensal * 12:.2f}%
"""
    return resposta

# Carrega a planilha uma vez quando o aplicativo inicia
carregar_planilha()

# Prepara a lista de administradoras para o Gradio
def get_administradoras_options():
    if df is not None:
        adm_list = df[df['tipo_do_bem'].str.lower() == 'imovel']['administradora'].unique()
        return sorted(adm_list)
    return []

# Criando a interface Gradio
with gr.Blocks(title="Sistema de Busca de Consórcio Imóvel") as demo:
    gr.Markdown("# 🏠 Busca de Combinações de Consórcio Imóvel")
    gr.Markdown("Insira os valores desejados para crédito, entrada e parcela, e filtre por administradora.")

    with gr.Row():
        credito_input = gr.Number(label="Crédito Desejado (R$)", value=300000, step=1000)
        entrada_input = gr.Number(label="Entrada Desejada (R$)", value=30000, step=1000)
        parcela_input = gr.Number(label="Parcela Desejada (R$)", value=1500, step=100)

    administradoras_multiselect = gr.CheckboxGroup(
        label="Filtrar por Administradoras",
        choices=get_administradoras_options(),
        value=get_administradoras_options() # Seleciona todas por padrão
    )

    submit_btn = gr.Button("🔍 Buscar Combinações", variant="primary")

    output_text = gr.Textbox(label="Resultados da Busca", lines=20, max_lines=40, interactive=False, placeholder="Os resultados aparecerão aqui...")

    submit_btn.click(
        fn=buscar_combinacoes,
        inputs=[credito_input, entrada_input, parcela_input, administradoras_multiselect],
        outputs=output_text
    )

    gr.Markdown("---")
    gr.Markdown("Desenvolvido para auxiliar na busca por cotas de consórcio ideais.")

# Inicia o aplicativo Gradio
if __name__ == "__main__":
    demo.launch() # Você não precisa disso no Colab, mas sim no arquivo que você fará o deploy
